\chapter{Multi-player games}

In this chapter we'll consider decision-making in a multi-palyer
games -- the case when the state of a game can change unpredictably
due to a move of a counterparty. Games like Chess, Checkers, Go
are all good examples of two-player games. Building a computer
program that can play these games is difficult, but ideas behind
several approaches can be studied on a game as simple as Tic-Tac-Toe.

\section{Tic-Tac-Toe -- the game}

Two players make moves on a 3x3 board. They start with an empty board

\begin{center}
\begin{tabular}{ l | c | r }
     &  &  \\ \hline
     &  &  \\ \hline
     &  &  \\
  \end{tabular}
\end{center}
First player puts X in a free space,
the second player puts O. The player who first puts 3 symbols in a row is
the winner. Examples of winning positions:

\begin{center}
\begin{tabular}{ l | c | r }
    X & O & O \\ \hline
     & X &  \\ \hline
     &  & X  \\
  \end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | c | r }
    X &  & X \\ \hline
    O & O & O \\ \hline
      & X & X  \\
  \end{tabular}
\end{center}

There may be conditions when the board is full and there is no winner (draw):

\begin{center}
\begin{tabular}{ l | c | r }
    X & O & X \\ \hline
    O & X & O \\ \hline
    O & X & X  \\
  \end{tabular}
\end{center}


We'll be describing the position on the board by the list of 9 symbols:
"X", "O", or "\ " (empty space). For example, three positions above will be
["X", "O", "O", "\ ", "X", "\ ", "\ ", "\ ", "X"],
["X", " ", "X", "O", "O", "O", "\ ", "X", "X"], and
["X", "O", "X", "O", "X", "O", "O", "X", "X"].

\begin{tcolorbox}
\textbf{Python:} to continue you need to learn elements of
object-oriented programming -- classes in Python, constructors, member
functions and variables.
\end{tcolorbox}

There are several approaches to building a computer program that can
play Tic-Tac-Toe or other similar two-player games:

\begin{enumerate}
\item We can hard-code some strategy -- a set of rules the program
applies to choose next step. For example, two obvious rules are:
"\textbf{win}: if you have two symbols in a row and
can put the third symbol, do and win",
"\textbf{don't let win}: if on the next step your competitor
can win by putting third symbol, prevent this".
It can be shown that Tic-Tac-Toe has a winning strategy.
\item The first approach is hard to generalize -- it's close to impossible
to apply it to a game
just a little more complex than Tic-Tac-Toe. We can introduce
a general way of choosing next move that increases the chances of
a win -- so called minimax approach.
\item We'll find that minimax may require a lot of resources to evaluate
a move and the next approach will be the reinforcement learning
(Q-learning) to construct an evaluation function. The program
will first play with itself for some time and will eventually build a
model that can play against a human or other program.
\end{enumerate}

Let's start with a simple rule-based strategy -- we'll
implement two rules we've mentioned above (win and don't let win)
and for all other cases the program will be doing a random move.
We'll leave the development of a stronger rule-based strategy for
the challenge in the end of the chapter.

We have to prepare several service elements:

\begin{enumerate}
\item The class that implements the board and board-related functions.
\item Two classes that implement a computer player and a human player.
Computer player is making a move based on one or the other algorithm, and
the human player enters moves from the console.
\item The class that implements the game -- the order of operations,
position evaluation, etc.
\end{enumerate}

All those entities -- board, players, game -- have own data and functionality
and it's convenient to organize it as class member variables and functions.

\subsection{The board}

Let's first review the functionality related to the board and
not related to player's decisions, to the order of players moves, etc.
Any implementation of the board has to be able to do the following:

\begin{enumerate}
\item Initialize the empty board.
\item Check if the board is filled -- no moves available, or there is a winner
\item Check if a player is a winner.
\item Change its own state on move.
\item Find all possible moves (indices of all empty cells).
\item Return human-readable representation.
\end{enumerate}

Here is the implementation:

\begin{lstlisting}[language=Python,style=codelst2,caption={Tic-Tac-Toe: board}]
class board:
    def __init__(self):
        self.empty = " "
        self.buffer = [self.empty] * 9

    def filled(self):
        return len([x for x in self.buffer if x is self.empty])==0 \
               or self.winner("X") or self.winner("O")

    def winner(self,p):
        winning_lines = [[0,1,2],[3,4,5],[6,7,8],
                         [0,3,6],[1,4,7],[2,5,8],
                         [0,4,8],[2,4,6]]
        for line in winning_lines:
            if self.buffer[line[0]] == p and \
               self.buffer[line[1]] == p and \
               self.buffer[line[2]] == p:
                return True
        return False

    def on_move(self,move,symbol):
        self.buffer[move] = symbol

    def moves(self):
        return [c[0] for c in enumerate(self.buffer) if c[1] is self.empty]

    def __repr__(self):
        return "{}|{}|{}\n-----\n{}|{}|{}\n-----\n{}|{}|{}".format(*self.buffer)
\end{lstlisting}

\textbf{\_\_init\_\_} initializes buffer of 9 symbols of empty space.

\textbf{filled} checks number of empty spaces and winners.

\textbf{winner} checks if symbol \textbf{p} is the winer.

\textbf{on\_move} updates the buffer -- writes the symbol of the move
to the move position.

\textbf{moves} returns indices of empty spaces. Function \textbf{enumerate}
returns enumerated list, for example \textbf{enumerate(["a","b"])} returns
\textbf{[(0,"a"),(1,"b")]}.

And last function returns text representation of a board.

\begin{tcolorbox}
\textbf{Assignment:} change the function \textbf{winner} -- do not use
hard-coded winning lines.
\end{tcolorbox}

\subsection{Players}

Next elements of the game are two players -- player-computer and
player-human. The former has to make moves based on some algorithm,
the latter is accepting moves from a human player. Let's assume
the computer always makes first move.

The base class:

\begin{lstlisting}[language=Python,style=codelst2,caption={Tic-Tac-Toe: player, base class}]
class player:
    def __init__(self,symbol):
        self.symbol = symbol

    def move(self,board):
        pass
\end{lstlisting}
We need only two functions -- initialization (assigning a symbol)
and making a move (doesn't do anything in the base class).

Two derived classes:

\begin{lstlisting}[language=Python,style=codelst2,caption={Tic-Tac-Toe: player-computer}]
class computer(player):
    def __init__(self):
        player.__init__(self,"X")

    def move(self,board):
        options = board.moves()
        return options[randint(0,len(options)-1)]
\end{lstlisting}

\begin{lstlisting}[language=Python,style=codelst2,caption={Tic-Tac-Toe: player accepting moves from a human}]
class human(player):
    def __init__(self):
        player.__init__(self,"O")
    
    def move(self,board):
        print board
        i = int(input(">"))
        if i not in board.moves(): return self.board.move(board)
        return i
\end{lstlisting}

Initialization functions specify symbols.

Computer player makes move randomly -- first it takes all
available moves for the board and returns the value at a random index.

\textbf{move} function for a human player first prints the board and then
waits for the human input. If the input is not in the list of available
moves it calls itself to re-request the input from the player.

\subsection{The game}

And finally let's consider the implementation of the game.
We'll need several functions:
\begin{enumerate}
\item Initialization -- creating an empty board, and initializing players.
\item After each move we need to switch players.
\item Functions that control the game -- taking a move from a player
and updating the state of the game until the board is filled.
\item In the end of the game we want to show the final state.
\end{enumerate}

Here is the code:

\begin{lstlisting}[language=Python,style=codelst2,caption={Tic-Tac-Toe: the game}]
class TTTRandom:
    def __init__(self,player1,player2):
        self.player1 = player1
        self.player2 = player2
        self.board = board()

    def switch(self):
        # using a,b=b,a to exchange two variables
        self.player1, self.player2 = self.player2, self.player1

    def play(self):
        while not self.board.filled():
            move = self.player1.move(self.board)
            self.on_move(move)

    def on_move(self,move):
        self.board.on_move(move,self.player1.symbol)
        if self.board.filled():
            self.done()
        else:
            self.switch()

    def done(self):
        print "Done:"
        print self.board
\end{lstlisting}
Review the code and confirm that it implements all elements listed above.

And this is the code to play the game:

\begin{lstlisting}[language=Python,style=codelst2,caption={Tic-Tac-Toe: playing the game}]
p1 = computer()
p2 = human()
game = TTTRandom(p1,p2)
game.play()
\end{lstlisting}

\textbf{Assignments:}
\begin{enumerate}
\item Combine the code for the board, players, and the game. Play the game.
\item Change \textbf{move} function to support "win and don't let win"
strategy.
\end{enumerate}


\section{Tic-Tac-Toe, minimax approach}

As we can see implementing rule-based strategy can be a problem
even for simple games like Tic-Tac-Toe. Small size of the board
simplifies development, but any changes in rules or in size
would require starting from scratch. At the same time the number
of possible moves is finite and we can try to review all possibilities
and to choose winning moves. The number of possibilities can be
huge for games like Chess, but for Tic-Tac-Toe we can consider
all possibilities and build an optimal player.

The problem with the development is that we don't know how an
opponent moves - the opponent may follow the strategy we don't know
in advance. To address the issue we must assume that both
players move optimally trying to maximize the reward.

Consider the following example.

\begin{figure}[H]
\centering
\Tree[ .Start [ .2  5 6 ] [ .4 1 10 ] ]
\end{figure}

This is the tree of the game. First player makes first move
(from \textbf{Start} to \textbf{2} or \textbf{4}), then the second
player makes a move. Numbers associated with graph nodes are rewards.

Two players play against each other. First player is trying to maximize
the final reward - the reward in the end of the game after the second
move. First player is a \textbf{maximizer}. Second player
is minimizer and is trying to minimize the final reward.

Let's see what can be a sequence of moves:

\begin{enumerate}
\item First player moves to \textbf{4}. In this case the second player will
choose \textbf{1} as it's the minimum.
\item First player moves to \textbf{2}. The second player will choose \textbf{5}.
\end{enumerate}

Assuming that the second player chooses optimally the first player should
move to \textbf{2} -- the final reward in this case is \textbf{5} compared
to \textbf{1} in the other case. The assumption of optimal player is
crucial here -- for example the second player choosing randomly may choose
\textbf{10}.

The idea of the approach can be expressed in the following way:
\textbf{a player must choose a move that minimizes the maximum
reward of an opponent}. Remember that we have players of two types --
minimizers and maximizers. A minimizer reads the rule as
\textbf{a move that maximizes the minimum reward of an opponent}.

For games like Tic-Tac-Toe the reward is known only in the end of the
game -- a player either wins or looses or the game ends with draw.
First player (X) is a maximizer and in the case it wins the reward
is +1. The second player is a minimizer and the reward is -1. Reward
at a draw is 0.

To apply this approach to Tic-Tac-Toe we need to construct a computer
player that analyzes the game tree (all possible moves) and each time
chooses the best \textbf{minimax} move. Each move creates a new position
on the board until the game is over. We can use recursion to
build the game tree and analyze results of a move.

The Python code is similar to the code we developed in the previous section,
but we need to make several changes:

\begin{enumerate}
\item class \textbf{board} needs a function that returns reward
depending on the state of the board.
\item class \textbf{computer} needs an implementation of \textbf{minimax}
function and changes in \textbf{move} function.
\end{enumerate}

Here is the code:

\begin{lstlisting}[language=Python,style=codelst2,caption={Tic-Tac-Toe: the board, reward function}]
class board:

    ...

    def reward(self):
        if self.winner("X"): return 1.0
        if self.winner("O"): return -1.0
        return 0.0

    ...
\end{lstlisting}
The function returns non-zero reward depending on the winner (X or O)
and zero in all other cases.

\begin{lstlisting}[language=Python,style=codelst2,caption={Tic-Tac-Toe: minimax computer player}]
class computer(player):

    ...

    def minimax(self,board,maximizing):
        score = board.reward()
        if score != 0: return score
        if board.filled(): return 0
        if maximizing:
            best = -10000.0
            for m in board.moves():
                m_board = deepcopy(board)
                m_board.on_move(m,"X")
                best = max(best,self.minimax(m_board,not maximizing))
        else:
            best = 10000.0
            for m in board.moves():
                m_board = deepcopy(board)
                m_board.on_move(m,"O")
                best = min(best,self.minimax(m_board,not maximizing))
        return best
\end{lstlisting}
The function takes three parameters: \textbf{self} as 
any member function, \textbf{board} -- the same as in the previous
section, and \textbf{maximizing} -- boolean flag indicating a
maximizer or minimizer.

First we are getting the current reward
from the board. If the reward (\textbf{score}) is +1 or -1 (non-zero)
the function returns the value. 
If the score is 0 and the board is filled (draw) the function returns 0.
In all other cases we have moves to make. Each move returns new
score and we are choosing the best score. The notion of the best depends on
the \textbf{maximizing} flag -- it is \textbf{max} for a maximizer
and \textbf{min} for a minimizer.
Note that we are altering
\textbf{maximizing} flag -- if current player is a maximizer the next move
makes a minimizer and vice versa -- when calling \textbf{self.minimax}
recursively we are using \textbf{not maximizing} expression.

\begin{lstlisting}[language=Python,style=codelst2,caption={Tic-Tac-Toe: computer player, move funtion}]
class computer(player):

    ...

    def move(self,board):
        moves = board.moves()
        mm = []
        for m in moves:
            m_board = deepcopy(board)
            m_board.on_move(m,self.symbol)
            mm.append( self.minimax(m_board,False) )
        mm_index = mm.index(max(mm))
        return moves[mm_index]

    ...

\end{lstlisting}


