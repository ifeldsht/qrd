\chapter{Python basics}

This section covers elements of Python programming required to
complete the course. Please refer to a systematic course on Python
to learn more advanced elements of the language.

\section{Programming -- basic concepts}

Let's start with reviewing elements that don't dependent
on the programming language and then see how they work in
Python. Programs implement algorithms and
as a rule take some data as an input and generate data as an output.
Data types are domain-specific - different applications require
different data elements and
data organization, but the most common types are:

\begin{leftborder}
\begin{enumerate}
\item Logical constants: True and False.
\item Single numbers: last price on the market, number of
cars on the parking, age, number of seconds between two events,
universal constants, etc. 5, 3.1415926, 123.97.
\item Text: single characters, words, sentences, documents, text of news
\item Lists of elements: historical prices, weather records,
network traffic. Elements of lists can be accessed by their
position in the list - first element, second element, etc.
Lists are very common and fundamental in programming and in CS.
The name of one of the eldest programming languages -- LISP --
stands for LISt Processor.
\end{enumerate}
\end{leftborder}

\section{A few words on programming environments}
If Python is not installed please go to python.org and follow
instructions for your operating system.
We assume a student can create a text file with the code of the program
and execute command:

\begin{lstlisting}[language=bash,style=codelst2,caption={Python: runnning program saved in filename.py}]
python filename.py
\end{lstlisting}

Traditionally the first program is printing "Hello world!".
\footnote{Files with source codes of all examples are attached.}
Here is its listing in Python:

\begin{lstlisting}[style=codelst2, language=Python,caption={Python: Hello World!}]
print "Hello world!"
\end{lstlisting}

\bigskip
\begin{tcolorbox}
\textbf{Assignment:} create file HelloWorld.py with this program
and run in the command line:
\begin{lstlisting}[language=bash,frame=single,caption={Python: run HelloWorld.py}]
python HelloWorld.py
\end{lstlisting}
\end{tcolorbox}

\section{Basic operations}

Start Python interactive shell and enter commands (Listing A.2) one by one.

\begin{lstlisting}[style=codelst,language=Python,caption={Basic types}]
# Boolean
b = True

# Integer number
x = 2

# Float number
y = 1.23

# String
s = "Abc"

# List of numbers:
L = [1,2,3,4,5]

# print everything:
print b, x, y, s, L

# Operations:
b2 = not b
print b, b2

x2 = x * 31
print x, x2

y2 = y*y
print y, y2

s2 = s.lower()
print s, s2

L2 = L[::-1]
print L, L2

a = 2
b = "A"
print a, b
a, b = b, a
print a, b
\end{lstlisting}
Lines started with \# are comments, they are not executed.
Create file with commands and execute it. 

\section{Functions in Python}

We are using "def" to declare new function, list parameters in
parenthesis, and column ":" in the end of declaration
For example:

\begin{lstlisting}[style=codelst2,language=Python,caption={First function}]
def f(x): return x*x
\end{lstlisting}

Here we've declared function \textbf{f}. The function
 takes one parameter \textbf{x},
and returns the square of the parameter. The function
can fail if multiplication is not defined for the parameter \textbf{x} --
if it's a string for example. 

The function can have more than one line of code. We can re-write
the function from our example in the following way

\begin{lstlisting}[style=codelst2,language=Python,caption={Multi-line function}]
def f(x):
    x_squared = x*x
    return x_squared
\end{lstlisting}
Note indentation - usually it's 4 spaces. The indentation defines
the body of the function and affects "visibility" of variables. 
Consider the following code:

\begin{lstlisting}[style=codelst2,language=Python,caption={Visibility of variables}]
x = 1

def f(x):
    x2 = 2*x
    return x2

def g():
    x2 = 2*x
    return x2

print f(2)
print g()
\end{lstlisting}
First we've initialized variable \textbf{x} (line 1). Then we've
defined two functions:

\begin{enumerate}
\item \textbf{f} that takes a parameters with the same
name \textbf{x} and returns \textbf{2*x}. The variable x initialized on
the line 1 doesn't affect this function and
on the line 4 the variable \textbf{x} known to
the function f is equal 2.
\item \textbf{g} that doesn't take a parameter and returns \textbf{2*x} for
any \textbf{x} defined before the function call. In this case \textbf{g}
takes \textbf{x=1} defined on the line 1.
\end{enumerate}

Functions in Python can be nested - one function can be defined in
the body of other function:

\begin{lstlisting}[style=codelst2,language=Python,caption={Nested functions}]
x = 1

def f(x):
    x = 2*x
    def g(x):
        x = x+1
        return x
    return x + g(7)

print f(2)
\end{lstlisting}
There are three independent variables \textbf{x} here.
Note double indentation -- 8 spaces -- for the body of function \textbf{g}.

\bigskip
\begin{tcolorbox}
\textbf{Assignment:}
What are values of x when you are on the lines 1, 4, 6?
Add printing value of x in different parts of the code
to check your answer.
\end{tcolorbox}


\section{Conditions}
If you program need to change behaviour depending on some condition
you can use \textbf{if} statement.
Let's say you want to print numbers in words. On simple way of doing
this is to check the number and print accordingly.

\begin{lstlisting}[style=codelst2,language=Python,caption={Checking conditions}]
n = 1
if n = = 1:
    print "one"
elif n = = 2:
    print "two"
else:
    print "not one or two"
\end{lstlisting}
Here we are using two equality signs without spaces between 
to check the value.
\begin{itemize}
\item First we compare \textbf{n} with 1.
If n is equal to 1 we print the word "one".
\item If it's not we compare \textbf{n} with 2 (note the use of \textbf{elif} statement)
and print accordingly.
\item For all other cases (\textbf{n} is not 1 or 2) we use keyword \textbf{else}.
\end{itemize}


\section{Loops}
There exist cases when your program has to iterate over elements
of a list or a dictionary, or execute some part of a code several times
probably with different parameters. In such case we can use \textbf{for}
statement:

\begin{lstlisting}[style=codelst2,language=Python,caption="Loop"]
L = ["a", "b", "c", "def"]
for e in L:
    print e
\end{lstlisting}

Very common is the case when your program iterates over the
list elements using their indices. Index is position of an element
in the list:

\begin{lstlisting}[style=codelst2,language=Python,caption={Printing list elements by index - 1}]
L = ["a", "b", "c", "def"]
for i in range(4):
    print L[i]
\end{lstlisting}

\textbf{range(4)} is function returning list of integers from 0 to n-1.
The code above is equivalent to
\begin{lstlisting}[style=codelst2,language=Python,caption={Printing list elements by index - 2}]
L = ["a", "b", "c", "def"]
for i in [0,1,2,3]:
    print L[i]
\end{lstlisting}
Note that indices start from 0: index of the first element is 0, index of
the second element is 1, etc. For the list of N elements the index of the last element
is N-1.


\section{File input/output}

\subsection{Text files - reading/writing}

Text files of different formats -- not formated plain text,
comma-separated (CSV), JSON, XML -- are widely used for a number
of applications and we'll start with reading/writing text.

File is referenced by its name. File name may include directory name.
To start working with a file you need to open it:

\bigskip
\lstinline{f = open("filename.txt","r")}
\bigskip

Here function \textbf{open} takes two parameters - 
file name and mode of operation.
The mode \textbf{"r"} opens file for reading 
starting from the very beginning. Other modes are
\textbf{"w"} - open for writing. If file doesn't exist it'll 
be created. If file exists it'll be open as an empty one and 
existing content will be lost.
\textbf{"a"} - open for appending. If file exists it'll 
be open for writing to the end of the file.

The function \textbf{open} returns an object (variable \textbf{f}) 
used to actually read/write.

After reading/writing is done file must be closed:

\bigskip
\lstinline{f.close()}
\bigskip

Here is example:

\begin{lstlisting}[language=Python,style=codelst,caption={File operations}]
# create a file with one line of text inside:
f = open("filename.txt","w")
f.write("Hello world!")
f.close

# read the file and print its content:
f = open("filename.txt","r")
content = f.read()
f.close
print content

# append some text to the file
f = open("filename.txt","a")
f.write("Hello again")
f.close
\end{lstlisting}

\begin{tcolorbox}
\textbf{Assignments:}
experiment with opening files in different modes
and reading/writing. Be careful with modes of operation.
\end{tcolorbox}

\subsection{Command line arguments. Modules in Python.}

To open a file you need to provide a file name. This can be done
directly in the code (hardcode the name). In this case you'll need to change
your program to run for the other file. As an alternative you can
specify the name as a parameter in the command line:

\begin{lstlisting}[language=bash,frame=single]
python yourprogram.py filename.txt
\end{lstlisting}

The code above can be re-written in the following way:

\begin{lstlisting}[language=Python,style=codelst,caption={Command line parameter}]
import sys

# create a file with one line of text inside:
f = open(sys.argv[1],"w")
f.write("Hello world!")
f.close

# read the file and print its content:
f = open(sys.argv[1],"r")
content = f.read()
f.close
print content

# append some text to the file
f = open(sys.argv[1],"a")
f.write("Hello again")
f.close

\end{lstlisting}

First line contains new element: \textbf{import sys}.
Python is has a notion of a module -- the way of organizing
code. To start using a module it has to be imported.

Module \textbf{sys} provides system-level functionality.
\textbf{sys.argv} is the list of command line arguments starting
from the name of Python program file.

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: print command line arguments}]
import sys

for arg in sys.argv:
    print arg
\end{lstlisting}

\begin{tcolorbox}
\textbf{Assignments:}
\begin{itemize}
\item Run the code above with different parameters.
\item Write Python program that prints itself.
\end{itemize}
\end{tcolorbox}

This code prints all parts of command line. Note that all 
parameters (elements of \textbf{sys.argv}) are strings.
To pass a numerical value you need to convert corresponding parameter:

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: numbers in command line}]
import sys

x = sys.argv[1]
print x, type(x)
y = int(x)
print y, type(y)
\end{lstlisting}

Function \textbf{type} returns type of the argument --
string, integer, float, list, etc.


\section{File input/output, parsing strings}

Depending on the file format parsing its content 
may be more or less difficult.
For purposes of the course we need to parse maze descriptions 
saved in text files and convert them into trees.

Python program that reads and prints the content of the file:

%%%
\newpage

\begin{lstlisting}[language=Python,style=codelst2,caption={Reading file and printing its content}]
import sys

f = open(sys.argv[1],"r")
file_content = f.read()
f.close()

print file_content
\end{lstlisting}

First we need to split the file content into lines. Lines in files
end with invisible end-of-line (EOL) symbol or two 
symbols depending on the
operating system convention. In most of the cases
the symbol is \textbf{$\sim n$} or two symbols \textbf{$\sim r\sim n$}.
Backslash in the beginning indicates a special
kind of symbols used to format the text. The following code:

\begin{lstlisting}[language=Python,style=codelst2,caption={Splitting file into strings}]
lines = file_content.split("\n")
print lines
\end{lstlisting}

\begin{tcolorbox}
\textbf{Assignment:}
Combine two pieces of code and confirm the type of 
variable \textbf{lines} (List).
Print it element by element.
\end{tcolorbox}

Next step is to convert each line into a 
list of logical constants (True, False)
so that True corresponds to a path and False 
corresponds to a wall. For example
convert \textbf{0101010} into 
\lstinline{[False,True,False,True,False,True,False]}. One way of doing
this is to go character by character in a loop over the entire string,
compare characters with 1 and 0, and append new logical value to a list:

\begin{lstlisting}[language=Python,style=codelst2,caption={String element by element}]
line = "0101010"
num = len(line)
L = []
for i in range(num):
    is_path = line[i] == "1"
    L.append(is_path)
\end{lstlisting}
In this piece of code we first use function \textbf{len} to calculate
number of characters in the line. Next we create an empty list \textbf{L}.
We go character by character using their indices in the string
and compare them with "1". Logical variable 
\textbf{is\_path} is initialized
depending on the result of comparison with "1" and then appended to 
the list.

This way of coding is valid, but not very efficient and compact.
Instead of using loop we can use so called list comprehensions. For
a list L the following expression

\bigskip
\lstinline{[f(x) for x in L]}
\bigskip
creates a list constructed by applying 
function \textbf{f} to each element
of the list. For example:

\begin{lstlisting}[language=Python,style=codelst,caption={Python: list comprehensions}]
def f1(x):
    return x*2

def f2(x):
    return x*x

L = [1,2,3,4]
L1 = [f1(x) for x in L]
L2 = [f2(x) for x in L]
print L, L1, L2

# or the same in place:
L1 = [x*2 for x in L]
L2 = [x*x for x in L]
print L, L1, L2
\end{lstlisting}

A string in Python can be treated as a list 
(with some limitations).
The following code converts string \textbf{line} into a
list of characters it contains:

\begin{lstlisting}[language=Python,style=codelst2,caption={String to list}
line = "abc"
L = [x for x in line]
print line, L
\end{lstlisting}

Now we can rewrite the code converting string element by element into
logical variables in the following way:

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: string element by element}]
line = "0101010"
L = [x=="1" for x in line]
\end{lstlisting}
Here we use in place expression \textbf{x=="1"} 
for each element of the \textbf{line}.

\section{Image processing}

To proceed you need to install Python module Pillow. Run

\begin{lstlisting}[language=bash,frame=single]
pip install Pillow
\end{lstlisting}
or refer to online documentation (python-pillow.org) for your
operating system.

Here is the Python code that loads image from attached PNG file,
prints image size and mode,
converts image into list of pixels, prints maze definition,
creates new list of pixels RGB, changes color of several pixels
to red, and creates an image for the new list and saves it.

\begin{lstlisting}[language=Python,style=codelst,caption={Python: image operations}]
from PIL import Image

img = Image.open("maze_1s.png")

imglist = list(img.getdata())

w, h = img.size

for i in range(h):
    row = ["0" if p>192 else "1" \
           for p in imglist[(i*w):((i+1)*w)]]
    print "".join(row)

new_imglist = [(x,x,x) for x in imglist]
for i in range(100):
    new_imglist[i*w+i] = (255,0,0)

new_img = Image.new("RGB",img.size)
new_img.putdata(new_imglist)

new_img.save("test.jpg")
\end{lstlisting}

Let's review the code line by line:
\begin{itemize}
\item Import support for images from PIL package.
\item Load image from PNG file. 
\item Extract pixel data and convert it into a list of pixel colors.
\item Extract image size -- width and height.
\item In the loop over each row we create and print maze description 
("0" for wall, "1" for an element of path). Original image is
in gray -- shadows of gray are coded as integers between 0 and 255.
High values correspond to light gray. Everything above 192 is considered
to be a wall, everything darker is a path.
\item Create a new list: RGB triplets representing the same colors
as in the original image (all three components -- red, green, blue --
are identical).
\item To illustrate pixel color operations we change 100 pixels on the 
diagonal -- making them red. RGB value (255,0,0) corresponds to red color.
\item Create new image object: RGB color mode and the same size as in
the original image.
\item Create image pixel data from the list of RBG triplets.
\item Save new image as JPEG file.
\end{itemize}

You can use basic image operations to illustrate differences 
between graph search algorithms.

\section{Python modules}

Modules in Python is the way to organize and reuse code.
In the simplest case module is just a Python file with
functions or other Python elements.

If file \textbf{A.py} contains the following code:

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: one-file module}]
def f(x):
    print "Function f from A.py"
    return x*x
\end{lstlisting}
it can be used from other Python programs or in Python interactive 
shell:

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: accessing single-file module function - 1}]
import A
print A.f(2)
\end{lstlisting}
or
\begin{lstlisting}[language=Python,style=codelst2,caption={Python: accessing single-file module function - 2}]
from A import f
print f(2)
\end{lstlisting}

Bigger projects may include multiple files. In this case
module is organized by directory -- all files are saved to
the directory and the name of the directory becomes the
name of the module. In addition to Python files with
the module-specific functions one more service file is needed:
\textbf{{\_\_}init{\_\_}.py}. The file may be empty, but normally
it contains the list of elements. Consider the following
configuration: directory \textbf{module1} containing
three files: \textbf{func1.py}, \textbf{func2.py}, 
\textbf{{\_\_}init{\_\_}.py}. The code in files:

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: sample module -- file \textbf{finc1.py}}]
def f1(x):
    print "Function f1 from func1 from module1"
    return x*x

def f2(x):
    print "Function f2 from func1 from module1"
    return -x
\end{lstlisting}

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: sample module -- file \textbf{finc2.py}}]
def f1(x):
    print "Function f1 from func2 from module1"
    return x*x*x

def g(x):
    print "Function g from func2 from module1"
    return x+1000
\end{lstlisting}

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: sample module -- file \textbf{{\_\_}init{\_\_}.py}}]
__all__=["func1","func2"]
\end{lstlisting}

There are several ways to access functions from this module:

%%%
\newpage

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: accessing module functions - 1}]
import module1.func1
import module1.func2

print module1.func1.f1(2)
print module1.func1.f2(7)
print module1.func2.f1(3)
print module1.func2.g(234)
\end{lstlisting}

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: accessing module functions - 2}]
from module1 import *

print func1.f1(2)
print func1.f2(7)
print func2.f1(3)
print func2.g(234)
\end{lstlisting}

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: accessing module functions - 3}]
from module1.func1 import *
from module1.func2 import f1 as f1A
from module1.func2 import g

print f1(2)
print f2(7)
print f1A(3)
print g(234)
\end{lstlisting}

\section{Random numbers}

There exist algorithms that require a random number generator.
You may want to simulate a coin toss and to generate a sequence
of 0s and 1s, or to generate a random initial state, like we did in
the section on 8-puzzle in this course. 

Python provides support for random numbers in the \textbf{random}
module. Here is the code that can be used to generate a sequence of
0s and 1s:

%%%
\newpage

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: random numbers, simulating a coin toss}]
from random import randint
for i in range(10):
    print randint(0,1)
\end{lstlisting}
The function \textbf{randint(A,B)} from the module \textbf{random}
returns a random integer from A to B inclusive. If you call this
function many times each number will appear equal number of times --
the function generates numbers \textbf{uniformly distributed}.
You can adjust the code above and confirm this -- just count the number 
of 0s and 1s after 100 or 1000 calls of the function.

The other useful function from the module \textbf{random} is
\textbf{random} (function name is the same as the module name):

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: random numbers in the interval (0,1)}]
from random import random
for i in range(10):
    print random()
\end{lstlisting}
The function doesn't take a parameter and returns a number between 0 and 1.
Numbers are also uniformly distributed -- if you call this function 
many times the number of cases when function returns a value in any 
interval of a given size will be the same. For example -- the number
of cases when the value is below 0.5 and above 0.5 (intervals (0,0.5)
and (0.5,1) are of equal sizes), or is in the interval (0.23,0.33) 
and (0.58,0.68).

For purposes of this course we don't need other types of 
distributions and other functions from the module.

\section{Classes}

Object-oriented programming (OOP) is one of the most powerful
and widely used programming concepts. Python supports OOP and
its core element -- the notion of classes. For purposes of this
course we'll consider just basic ideas without covering all
aspects of the concept. \footnote{
If you are familiar with OOP in other languages (similar to C++)
you'll find that implementation of classes in Python
assumes members (variables and functions) are public,
and functions are virtual.}

The idea of a class is to keep data and related functionality
together. Your program may work with objects described
by object-specific data -- for example, geometrical figures,
bank accounts, game boards, etc. Geometrical figures may be
given by a center and radius (circle) or by several sizes
(triangle, rectangle) or by position of corners (arbitrary
polygon). Bank account keeps information about the owner
(name, address, email, phone number), balance, transactions, etc.

When developing a program that works with multiple geometrical
figures we may need each figure to have a common interface
functions -- for example, the function that that returns a
position of a geometrical center, or a function that returns True
if a point is inside the figure and False otherwise. Those functions
are different for different geometrical figures and it's convenient
to isolate this functionality -- the program only "knows" that
each geometrical figure has functions \textbf{center()} and
\textbf{is\_inside(point)}.

To do this we first declare a base class common for all figures
and implementing common functionality:

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: base class}]
class figure(object):
    def __init__(self,name):
        self.name = name

    def center(self):
        pass

    def is_inside(self,point):
        pass

    def __repr__(self):
        return self.name
\end{lstlisting}
Let's go line by line:

\textbf{class figure(object):}

We've declared new class \textbf{figure} extending the base class
\textbf{object}. Object is the base class for almost everything in Python
 -- integers, lists, strings, etc. are all objects. What it means --
each derived class keeps (inherits) the functionality implemented
in the base class.

\textbf{ def \_\_init\_\_(self,name):}

Function \textbf{\_\_init\_\_} is called each time we create new object.
All member functions\footnote{except static functions not covered here} have
first parameter \textbf{self} -- the reference to the constructed object.
\textbf{\_\_init\_\_} may have other parameters to initialize member variables.
Here the parameter is \textbf{name} -- the name of the figure. Base class
doesn't know anything else -- all other details will be implemented in
classes derived from \textbf{figure}.

\textbf{self.name = name}

This line initializes member variable \textbf{self.name}. If we have an
instance of this class \textbf{f} the variable \textbf{name} can be
accessed as \textbf{f.name}.
Inside the class definition the first
part of this expression (the reference to the object) is \textbf{self}
and the variable is accessed as \textbf{self.name}.

Next we declare two function -- \textbf{center} and \textbf{is\_inside}.
We are using \textbf{pass} statement
to do nothing in the base class.

\textbf{def \_\_repr\_\_(self):}

Function \textbf{\_\_repr\_\_} returns a string representation of the
object. It's called each time we print something -- Python statement
\textbf{print x} prints the string returned by \textbf{x.\_\_repr\_\_()}.
For the base class this function returns the name of the figure.


Now we want to implement a rectangle. For demonstration purposes
we'll assume the corners at points $(0,0), (w,0), (0,h), (w,h)$ --
we need only two numbers to describe any rectangle -- width \textbf{w}
and height \textbf{h}.

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: derived class (rectangle)}]
class rectangle(figure):
    def __init__(self,w,h):
        figure.__init__(self,"rectangle")
        self.w = w
        self.h = h

    def center(self):
        return (self.w/2,self.h/2)

    def is_center(self,point):
        return point[0]>0 and point[0]<w and\
               point[1]>0 and point[1]<h

    def __repr__(self):
        return "{}, width={}, height={}"\
               .format(self.name,self.w,self.h)
\end{lstlisting}
Note that \textbf{\_\_init\_\_} function now has different
parameters. In the beginning it calls the corresponding function
of the base class \textbf{figure}. In this case the initialization
is trivial, but in more complicated cases the reuse may be
extremely helpful. \textbf{\_\_repr\_\_} returns the string with
name and parameters.

Here is the class implementing the same functions for circle given
by radius \textbf{r} and the position of center \textbf{c}:

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: derived class (circle)}]
class circle(figure):
    def __init__(self,r,c):
        figure.__init__(self,"circle")
        self.r = r
        self.c = c

    def center(self):
        return self.c

    def is_center(self,point):
        return (point[0]-self.c[0])*(point[0]-self.c[0])+\
               (point[1]-self.c[1])*(point[1]-self.c[1]) \
               < self.r*self.r

    def __repr__(self):
        return "{}, radius={}, center={}"\
               .format(self.name,self.w,self.h)
\end{lstlisting}
Now let's learn how to use these classes:

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: using classes}]
fig = figure("unknown figure")
rect = rectangle(2.0,1.0)
circ = circle(3.0, (1.0,4.0))

print type(fig), fig
print fig.ceneter(), fig.is_inside((0.0,0.0))
print type(rect), rect
print rect.ceneter(), rect.is_inside((0.5,1.2))
print type(circ), circ
print circ.ceneter(), circ.is_inside((2.0,4.0))
\end{lstlisting}
We first created three objects -- basic figure, rectangle and circle and then
called corresponding functions. The same can be done in a loop:

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: using classes - 2}]
L = []
L.append( figure("unknown figure") )
L.append( rectangle(2.0,1.0) )
L.append( circle(3.0, (1.0,4.0)) )

for f in L:
    print type(f), f
    print f.ceneter(), f.is_inside((0.5,1.0))
\end{lstlisting}

This section doesn't cover all aspects of classes in Python, it
considers only very basic elements needed for the development.

\section{Saving Python structures. JSON.}

Sometimes you need to save results of calculations for future use.
Sometimes the task is simple - a number can be saved in a text file,
list of numbers may be a column in a comma-separated (CSV) file.
What if we need to save a more complex, nested structure.
Consider the following variable:

\begin{lstlisting}[language=Python,style=codelst2]
X = {}
X["abc"] = [ 1, 2, [3, [4, 6, 6]], 7, 8 ]
X["def"] = { "A":34.567, "B":98.765 }
X["ghi"] = "Sample text"
\end{lstlisting}
Each element value of this dictionary has different type -- nested list,
dictionary, string. We can introduce a custom solution for this particular
case, but it may not work for other cases. It would be convenient to have
a way to save arbitrary Python variables and then load them without
doing task-specific parsing.

The Python module \textbf{json} \footnote{JSON stands for
JavaScript Object Notation. This format is
is widely used for data exchange.}
allows to do exactly this.
Here is how we can save the variable \textbf{X} from the example above:
we import new module, create a variable, open file for writing
and save (dump) it using \textbf{json.dump} function.

%%%
\newpage

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: save to JSON file}]
import json

X = {}
X["abc"] = [ 1, 2, [3, [4, 6, 6]], 7, 8 ]
X["def"] = { "A":34.567, "B":98.765 }
X["ghi"] = "Sample text"

f = open("example.json","w")
json.dump(X,f)
f.close()
\end{lstlisting}
Run this code and make sure the file is created.
Now we can load the variable:

\begin{lstlisting}[language=Python,style=codelst2,caption={Python: load from JSON file}]
import json

f = open("example.json","r")
Y = json.load(f)
f.close()

print Y
\end{lstlisting}
Try this and confirm that the variable \textbf{Y} corresponds to
\textbf{X} from the previous example.


\section{Coding problems}

The best way to build practical skills in programming is to do
real development and solve practical problems with your language
of choice. In this section we present coding problems -- from elementary
to more complex. You can do them in an arbitrary order. Those of
you who are interested in solving advanced problems can start 
with Project Euler \footnote{https://projecteuler.net/}.

Problems:

\begin{enumerate}
\item Write a function that takes a day of a week (for example "Monday")
as a parameter and returns True for weekends and False for weekdays.
\item Write a function that takes a day of a year and returns 
the month. For example given 67 it returns "March".
\item Define night as the time between 22:00 and 5:50. 
Write a function that takes hours and minutes and returns True if
it's night and False otherwise. For example True for 23 and 4:41, 
an False for 5:51.
\item Write a function that parses string with a date and returns
all elements -- year, month, day as integers. For example, for
"January 04, 2018" it returns (2018,1,4). You can assume this format of
the date (month as a string, two-digit day, comma, four-digit year).
\item Write a function that removes all spaces from a given string
and makes first letters of all words in the upper case. For example
it converts "This is a sample string." into "ThisIsASampleString".
\item Write a function that reads a text file and returns word frequencies 
-- for each word it calculates the number of cases it appears in the
text.
\item Write a function that returns all unique elements of a list. 
For example, for [1,2,1,4,5,2] it returns [1,2,4,5].
\item Write a function that returns a sums of two sequential elements of
a list. For example, for [1,2,3,10,20] it returns [3,5,13,30]. 
\item Write a function that sorts a list (do not use sorting functions 
provided by Python). 
\item Write a function that for a given dictionary (key:value pairs)
returns (value:[key]) dictionary. For example, for {"a":1,"b":2,"c":1}
it returns {1:["a","c"],2:["b"]}
\item Write a function that rounds a number (do not use rounding functions
provided by Python).
\item Write a function that transposes a list of lists. For example,
for [[1,2,3],[4,5,6]] it returns [[1,4],[2,5],[3,6]].
\item Write a function that returns True for prime numbers and
False otherwise.
\item Write a function that for a given number 
returns all prime numbers below it. For example, for 15 returns
[2,3,5,7,11,13].
\item Write a function that returns all possible combinations
of two elements for a given list. For example, for [1,2,3] it
returns [[1,2],[1,3],[2,3],[2,1],[3,1],[3,2]] (do not use
functions available in Python).
\end{enumerate}

Try to find more than one solution. 








